# 필요성

컨테이너 오케스트레이션을 위해 필요. 컨테이너 인프라 환경에서 수 많은 컨테이너를 관리하기 위해 필요한 컨테이너 관리 도구중 사실상 표준이다(CNCF 프로젝트).
컨테이너 배포 및 스케줄링, 로드밸런싱 등 오케스트레이션 툴이 없다면 수동으로 제어해야하는 작업들을 자동화 하여 서비스 운영에 도움을 준다.

# 특징

#### 선언적 API

컨테이너 상태를 선언하면 쿠버네티스가 설정된 상태를 맞추는 개념 (예: 레플리카). 선언적이기 때문에 관리가 편리함.

#### 워크로드 분리

# 기능

### 셀프 힐링

에러가 발생한 컨테이너를 재시작하고, 노드가 죽었을 때 컨테이너를 교체하기 위해 다시 스케줄하고, 사용자 정의 상태 체크에 응답하지 않는 컨테이너를 제거하며,
서비스를 제공할 준비가 될 때까지 클라이언트에 해당 컨테이너를 알리지 않는다.

### 스케일링

CPU 사용량에 따라 자동으로 애플리케이션의 스케일을 업 또는 다운한다.

### 서비스 디스커버리와 로드밸런싱

쿠버네티스를 사용하면 익숙하지 않은 서비스 디스커버리 메커니즘을 사용하기 위해 애플리케이션을 수정할 필요가 없다. 
파드에게 고유한 IP 주소와 파드 집합에 대한 단일 DNS 명을 부여하고, 그것들 간에 로드-밸런스를 수행할 수 있다

### 자동화된 롤아웃과 롤백

애플리케이션의 설정 변경시 점진적으로 롤아웃하는 동시에 애플리케이션을 모니터링해서 모든 인스턴스가 동시에 종료되지 않도록 보장한다. 
만약 어떤 문제가 발생하면 쿠버네티스는 변경 사항을 롤백한다.


### 스토리지 오케스트레이션

로컬 저장소, 클라우드 프로바이더 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있다.




# 구성 요소

![image](https://user-images.githubusercontent.com/28949162/211334863-93e1ac07-b79d-4a49-bfe2-9131ac56255d.png)


### 컨트롤 플레인 컴포넌트(마스터 노드)

클러스터 관리(스케줄링 등) 클러스터 이벤트 감지 및 반응(예: 레플리카 수 유지)

#### Kube-API-Server

쿠버네티스 API를 노출

#### etcd
클러스터 데이터를 저장하는 key-value 저장소. 백업 필수.
#### kube-scheduler

파드를 노드에 스케줄링. 
스케줄링 결정을 위해서 고려되는 요소는 리소스 요구 사항, 하드웨어/소프트웨어/정책적 제약, 
어피니티(affinity) 및 안티-어피니티(anti-affinity) 명세, 데이터 지역성, 워크로드-간 간섭, 데드라인을 포함.

#### kube-controller-manager

API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.

노드 컨트롤러: 노드가 다운되었을 때 통지와 대응에 관한 책임을 가진다.

잡 컨트롤러: 일회성 작업을 나타내는 잡 오브젝트를 감시한 다음, 해당 작업을 완료할 때까지 동작하는 파드를 생성한다.

엔드포인트 컨트롤러: 엔드포인트 오브젝트를 채운다(즉, 서비스와 파드를 연결시킨다.)

서비스 어카운트 & 토큰 컨트롤러: 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성한다.

#### cloud-controller-manager
 
클라우드 컨트롤러 매니저를 통해 클러스터를 클라우드 공급자의 API에 연결하고, 해당 클라우드 플랫폼과 상호 작용하는 컴포넌트와 클러스터와만 상호 작용하는 컴포넌트를 구분할 수 있게 해 준다.

### 노드 컴포넌트(워커 노드)

### 애드온

# 동작 원리


Reference
- https://kubernetes.io/ko/
- https://kubernetes.io/ko/docs/concepts/overview/
