#### 마스터 노드 컴포넌트 무엇이 있을까요?

```
Kube-API-Server: 모든 API 호출을 받아들이고 처리하는 컴포넌트. 

etcd: 클러스터의 데이터를 저장하는 key-value 저장소. 쿠버네티스 리소스의 상태 정보, 구성 정보 등을 저장하며, 클러스터의 높은 가용성과 일관성을 보장. 백업 필수.

kube-scheduler: 파드를 노드에 스케줄링. 스케줄링 결정을 위해서 고려되는 요소는 리소스 요구 사항, 하드웨어/소프트웨어/정책적 제약, 어피니티(affinity) 및 안티-어피니티(anti-affinity) 명세, 데이터 지역성, 워크로드-간 간섭, 데드라인을 포함.

kube-controller-manager: API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.

노드 컨트롤러: 노드가 다운되었을 때 통지와 대응에 관한 책임을 가진다.

잡 컨트롤러: 일회성 작업을 나타내는 잡 오브젝트를 감시한 다음, 해당 작업을 완료할 때까지 동작하는 파드를 생성한다.

엔드포인트 컨트롤러: 엔드포인트 오브젝트를 채운다(즉, 서비스와 파드를 연결시킨다.)

서비스 어카운트 & 토큰 컨트롤러: 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성한다.

cloud-controller-manager: 클라우드 컨트롤러 매니저를 통해 클러스터를 클라우드 공급자의 API에 연결하고, 해당 클라우드 플랫폼과 상호 작용하는 컴포넌트와 클러스터와만 상호 작용하는 컴포넌트를 구분할 수 있게 해 준다.
```

#### 쿠버네티스를 왜 써요?

```
컨테이너 오케스트레이션을 위해 필요. 컨테이너 인프라 환경에서 수 많은 컨테이너를 관리하기 위해 필요한 컨테이너 관리 도구중 사실상 표준이다(CNCF 프로젝트). 컨테이너 배포 및 스케줄링, 로드밸런싱 등 오케스트레이션 툴이 없다면 수동으로 제어해야하는 작업들을 자동화 하여 서비스 운영에 도움을 준다.

쿠버네티스를 사용하면 확장성, 가용성, 자동화에 도움이된다.

확장성: 쿠버네티스는 자동으로 노드를 추가하고 컨테이너를 배포하여 처리하여 애플리케이션 부하 증가에도 대처가 쉽다.
가용성: 쿠버네티스는 여러 노드에 컨테이너를 분산시켜 실행하므로, 단일 노드나 컨테이너의 장애가 발생해도 애플리케이션의 가용성을 보장할 수 있다.
자동화: 컨테이너 배포및 스케일링을 자동화하여 운영 자동화에 도움을 준다.
```

#### 쿠버네티스 동작 과정

```
1. 컨테이너 이미지 빌드 및 레지스트리 등록
먼저, 개발자는 애플리케이션을 컨테이너 이미지로 빌드합니다. 이때, Docker와 같은 도구를 사용하여 이미지를 생성하고, 이를 레지스트리에 등록합니다.

2. kubectl create -> API Server

kube API server에 오브젝트 생성 요청. 쿠버네티스 오브젝트는 YAML 파일 형태로 정의되며, 파드(Pod), 레플리카셋(ReplicaSet), 디플로이먼트(Deployment) 등이 포함됩니다.

3. API Server -> Scheduler

API Server가 스케줄러에 오브젝트 스케줄링을 요청. 스케줄러는 노드의 상태를 확인하고 스케줄링할 노드를 선택.

4. Scheduler -> Kubelet

선택한 노드의 쿠블렛에 파드 생성을 요청.
kubelet이 컨테이너 런타임에 컨테이너 생성을 요청. 컨테이너 런타임은 이미지 레지스트리를 통해 이미지를 풀하고 컨테이너를 생성한다.

노드는 kubelet이라는 에이전트 프로그램을 실행하고 있으며, kubelet은 마스터 노드로부터 할당받은 파드와 컨테이너 정보를 확인하고, 컨테이너를 실행합니다.
이후, 컨트롤러는 레플리카셋의 설정에 따라 파드의 개수를 늘리거나 줄일 수 있으며, 파드의 상태를 주기적으로 확인하고, 장애가 발생한 경우 자동으로 파드를 재시작합니다.
```


#### 쿠버네티스에서 헬스체크를 어떻게 하는지?

```
헬스체크는 쿠버네티스에서 파드를 모니터링하고 상태를 정기적으로 확인하고 대처하는 매커니즘이다.

헬스체크 방법으로는 Liveness Probe, Readiness Probe가 있다.

Liveness Probe: 컨테이너가 정상적으로 실행되는지 확인. 정상 실행 상태가 아니면 kubelet이 컨테이너 실행을 중단시키고 컨테이너의 재시작 정책에 따라 컨테이너를 재시작한다.
Readiness Probe: 실제로 컨테이너가 요청을 처리할 준비가 되어있는지 확인. 일정 시간 내에 응답을 받지 못하면 파드가 서비스 프록시에서 제외된다.
```

#### 쿠버네티스 DNS 시스템이 어떻게 되는지?

```
쿠버네티스 클러스터는 DNS 시스템을 내장하여, 클러스터 내부에서 SD를 제공. 이를 통해, 클러스터 내부의 파드와 서비스를 찾아서 통신할 수 있다.
기본적으로 CoreDNS를 사용한다. 각 서비스마다 자동으로 DNS 이름을 생성한다. 예를 들어, my-service라는 서비스가 default 네임스페이스에 있을 경우, DNS 이름은 my-service.default.svc.cluster.local이 된다.
```

#### 쿠버네티스 클러스터의 고가용성을 위해 무엇을 해야할까?

```
1. 마스터 노드의 HA: 마스터 노드를 여러대로 구성한다. 마스터 노드는 클러스터 상태 정보를 저장하는 DB인 ectd를 사용한다.
etcd 클러스터는 여러 대의 마스터 노드로 구성되며, 각 노드는 etcd 데이터를 복제하여 동기화 한다.
etcd 클러스터의 고가용성을 보장해야한다. 이를 위해 마스터 노드의 쿼럼을 깨지지 않게 해야한다.
쿼럼은 클러스터에서 다수의 노드가 동의하는 것을 나타내는데, 다수의 노드가 공동으로 데이터를 관리하며, 하나의 노드가 고장 나더라도 클러스터 전체가 정상적으로 동작할 수 있다.
quorum = (노드 수 / 2) + 1
2. 노드의 HA: 노드가 다운되었을 때 다른 노드에 파드를 재할당할 수 있어야 합니다. 이를 위해, 레플리카셋(ReplicaSet)을 사용하여 파드를 복제하고, 파드를 다른 노드에 재할당할 수 있도록 합니다.
3. 스토리지의 HA: 스토리지를 여러 노드에 분산하여 저장하고, 복제하여 데이터를 안전하게 보호합니다. 이를 위해, 쿠버네티스에서는 StatefulSet과 같은 오브젝트를 사용하여 스토리지를 관리
4. 네트워크의 HA: 다중 네트워크 인터페이스를 사용하고, 여러 노드에서 동작하는 kube-proxy를 사용하여 로드 밸런싱을 수행합니다.
5. 백업 및 복구 전략: 백업 및 복구 전략을 수립하여 데이터를 안전하게 보호할 수 있도록 합니다.
```

#### 도커 왜 써요?

```
리소스를 격리하기 위해 가상화라는 개념이 등장했다. 가상화는 호스트 OS 위에 여러개의 독립된 게스트 OS를 띄워서 사용한다. 이런 가상화의 문제점은 이미지가 거대해지고(Guest OS에 커널을 포함) 성능 손실이 발생(Host OS를 거쳐야 하기 때문)한다는 것이다. 이 문제를 해결하기 위해 컨테이너가 나왔다. 도커 엔진 위에 컨테이너가 할당된다. 컨테이너는 애플리케이션을 구동하는 데 필요한 라이브러리 및 실행파일만 존재하기 때문에 이미지가 가볍다. 결과적으로, 도커를 사용하면 더 가볍고 빠르게 격리된 환경에서 애플리케이션을 구동할 수 있다.
```

#### 도커 레지스트리란? 어떤 레지스트리 사용했는지?

```
도커 이미지를 저장하고 관리하는 저장소.
도커 허브와 같은 퍼블릭 레지스트리가 있고, 하버나 넥서스 같은 프라이빗 레지스트리가 있다.
```

#### 도커의 동작 방식

```
도커 이미지 생성: 도커는 먼저 이미지를 생성합니다. 이미지는 컨테이너를 실행하는 데 필요한 파일과 설정 등을 포함한 패키지입니다. 도커 이미지는 Dockerfile이라는 특별한 문법을 사용하여 정의됩니다.

도커 이미지 저장: 생성된 이미지는 도커 레지스트리에 저장됩니다. 도커 레지스트리는 이미지를 중앙에서 관리하고, 다른 사용자나 개발자와 공유할 수 있도록 지원하는 서비스입니다.

도커 컨테이너 생성: 저장된 이미지를 바탕으로 도커는 컨테이너를 생성합니다. 컨테이너는 이미지에서 생성된 가상 환경이며, 애플리케이션을 실행하기 위한 필요한 모든 요소를 포함합니다.

컨테이너 실행: 생성된 컨테이너는 도커 엔진에 의해 실행됩니다. 컨테이너는 호스트 운영체제와는 독립적으로 실행되며, 애플리케이션의 실행 및 관리를 위한 필요한 기능을 제공합니다.

컨테이너 간 통신: 컨테이너는 네트워크를 통해 다른 컨테이너나 호스트 시스템과 통신할 수 있습니다. 컨테이너 간 통신을 위해 도커는 가상 네트워크를 제공하며, 컨테이너를 가상 네트워크에 연결하여 통신할 수 있습니다.

컨테이너 관리: 도커는 컨테이너를 관리하는 다양한 도구를 제공합니다. 이를 통해, 컨테이너의 상태 모니터링, 로깅, 설정 관리 등을 쉽게 수행할 수 있습니다.

컨테이너 삭제: 컨테이너를 더 이상 사용하지 않을 때, 도커는 해당 컨테이너를 삭제할 수 있습니다. 컨테이너를 삭제하면, 해당 컨테이너에서 실행 중인 애플리케이션과 관련된 데이터도 함께 삭제됩니다.
```

#### 도커 이미지란?

```
도커 이미지는 컨테이너를 생성하기 위한 실행 파일과 런타임 환경 등의 정보를 담고 있으
```

#### 컨테이너의 생명주기

```

이미지 생성: 먼저, Dockerfile 등의 설정을 통해 Docker 이미지를 생성합니다.

컨테이너 생성: 생성된 Docker 이미지를 바탕으로 컨테이너를 생성합니다.

컨테이너 시작: 생성된 컨테이너를 시작합니다.

컨테이너 실행: 컨테이너는 실행 중인 상태로 애플리케이션을 수행합니다.

컨테이너 일시 중지: 컨테이너를 일시 중지할 수 있습니다. 이때 컨테이너는 아직 메모리에 상주하며, 다시 시작할 수 있습니다.

컨테이너 종료: 컨테이너가 종료됩니다. 이때 컨테이너가 사용하던 자원은 반납됩니다.

컨테이너 삭제: 더 이상 필요하지 않은 컨테이너는 삭제됩니다. 이때 컨테이너 이미지는 유지됩니다.
```

#### 쿠버네티스 서비스 종류와 쓰임

```
쿠버네티스 파드는 컨트롤러가 관리하고, 한 군데에 고정되어있는 것이 아니라 클러스터 안을 옮겨 다닌다.
그렇기에 파드에 접근하는 방식이 필요하고 이를 서비스라고 한다.
서비스를 사용하면 고정 주소를 이용해 접근할 수 있다.

서비스 타입에는 크게 네 가지가 있다.

ClusterIP: 쿠버네티스 클러스터 내부에서만 접근 가능한 IP를 할당하는 서비스입니다. 여러 개의 포드를 하나의 IP로 묶어서 관리하며, 쿠버네티스의 내부 네트워크를 통해 접근할 수 있습니다.

NodePort: 쿠버네티스 클러스터 외부에서도 접근 가능한 포트를 열어주는 서비스입니다. 클러스터 내부에서의 ClusterIP 서비스와 함께 사용하여, 외부에서도 쿠버네티스 애플리케이션에 접근할 수 있도록 지원합니다. 
서비스 하나에 모든 노드의 지정된 포트를 할당한다. 
예) node1:8080 node2:8080

LoadBalancer: 클라우드 서비스가 제공하는 로드 밸런서와 파드를 연결하는 서비스입니다. 
해당 로드 밸런서의 IP를 이용해 클러스터 외부에서의 애플리케이션 접근을 지원하며 부하분산이 가능하다.

ExternalName: 외부 DNS 이름을 내부 클러스터에서 사용할 수 있도록 지원하는 서비스입니다. 즉, 서비스의 이름을 DNS 이름으로 지정하여, 클러스터 내부에서 외부 리소스에 접근할 수 있도록 합니다.

```

#### 도커 이미지란?

```
도커 이미지는 도커 컨테이너를 실행하기 위한 파일들의 묶음이다.

이미지는 레이어라는 개념을 사용하여 구성된다. 각 레이어는 이전 레이어를 기반으로 만들어진다. 변경사항이 있는 경우 전체 이미지를 다시 빌드하지 않고 변경된 레이어만 다시 빌드할 수 있도록 한다.
```

#### 쿠버네티스 인그레스와 서비스의 차이점
```
인그레스와 서비스는 모두 쿠버네티스 네트워크 개념이다.

인그레스는 클러스터 외부에서 내부로의 액세스를 제공하기 위한 기능이다. 일반적으로 HTTP 프로토콜을 사용하며, 로드 밸런싱과 SSL 종료 등의 기능을 제공.
인그레스를 사용하려면 인그레스 컨트롤러를 설치해야 한다. 인그레스 컨트롤러는 인그레스 규칙을 처리하고 요청을 적절한 서비스로 라우팅한다. 일반적으로 인그레스 컨트롤러는 Nginx, HAProxy와 같은 리버스 프록시를 사용한다.

서비스는 클러스터 내부에서 파드와 같은 워크로드에 대한 네트워크 엔드포인트를 노출하는 리소스. 서비스는 동일한 라벨 셀렉터를 사용하여 파드를 그룹화하고, 그룹 내의 파드에 대한 로드 밸런싱을 수행하며, 그룹 내 파드가 죽거나 생성될 때 업데이트를 자동으로 수행한다. 서비스는 일반적으로 TCP/UDP 프로토콜을 사용.

```
#### 쿠버네티스에서 셀프힐링하는 방법

```
1. 리드니스 프로브, 라이브니스 프로브
2. 노드 자동 복구: 노드에 장애가 발생하면 해당 노드의 파드를 다른 노드로 마이그레이션
```

#### 쿠버네티스 컨셉

```
느슨한 결합(Loose Coupling): 쿠버네티스는 애플리케이션의 컴포넌트를 느슨하게 결합하도록 설계되었다. 이를 통해, 컴포넌트를 개별적으로 배포하고, 교체하거나 업그레이드할 수 있다.

선언적(Declarative): 쿠버네티스는 선언적 API이다. 원하는 상태를 선언하면 쿠버네티스가 이를 달성하기 위해 자동으로 상태를 감시하고 변경한다.

자기 치유(Self-Healing): 쿠버네티스는 시스템의 가용성을 유지하기 위해 자동으로 문제를 해결하거나, 복구하는 기능을 제공.

자동화(Automated): 쿠버네티스는 시스템의 자동화를 지향. 따라서, 애플리케이션의 배포, 확장, 복구, 롤백 등의 작업을 자동으로 처리할 수 있다.

확장 가능(Scalable): 쿠버네티스는 수천 개의 노드(Node)를 지원하며, 클러스터의 크기를 쉽게 확장할 수 있다.

포터블(Portable): 쿠버네티스는 여러 환경에서 동일한 방식으로 실행할 수 있도록 설계되었다.
```

#### 느슨한 결합이란?

```
애플리케이션을 구성하는 컴포넌트들은 보통 서로 밀접하게 연결되어있다. 예를들어 웹 애플리케이션은 프론트엔드, 백엔드, DB 등의 컴포넌트가 서로 밀접하게 연결되어있다. 이런 구성에서는 하나의 컴포넌트를 변경하면 다른 컴포넌트도 함께 변경되야 하므로 유지 보수가 어렵고 장애 발생 시 시스템 전체에 영향을 미칠 수 있다.

쿠버네티스에서는 이러한 문제를 해결하기 위해 컴포넌트 간의 결합도를 낮추는 설계 철학을 따른다. 각 컴포넌트는 독립적인 프로세스로 실행되며, 서로 다른 노드에 배포될 수 있다.

쿠버네티스에서는 이러한 느슨한 결합을 구현하기 위해 다양한 기능을 제공한다. 예를 들어 각 파드는 독립적인 IP 주소를 가지며, 다른 파드와 통신할 때는 서비스를 사용한다. 서비스는 파드를 논리적으로 그룹화하여, 외부에서 파드에 접근할 때 로드 밸런싱과 같은 기능을 제공한다.

또한, 쿠버네티스에서는 컨트롤러를 사용하여 각 컴포넌트의 상태를 감시하고, 필요한 경우 컴포넌트의 수를 늘리거나 줄인다. 이를 통해, 컴포넌트의 수를 동적으로 조절하여 리소스를 효율적으로 활용할 수 있다.

또한, 쿠버네티스에서는 컨테이너 이미지를 사용하여 애플리케이션을 배포한다. 컨테이너 이미지는 독립적으로 실행될 수 있는 패키지로, 각 컴포넌트를 컨테이너 이미지로 패키징하여 배포한다. 이를 통해, 컴포넌트 간의 의존성을 낮추고, 배포 및 업그레이드를 보다 쉽게 처리할 수 있습니다.

또한, 쿠버네티스에서는 롤링 업데이트 기능을 제공합니다. 롤링 업데이트는 애플리케이션의 업그레이드를 점진적으로 처리하여, 장애 발생 시 시스템 전체에 영향을 최소화한다. 이를 통해, 애플리케이션의 가용성을 높일 수 있습니다.

쿠버네티스에서는 이러한 느슨한 결합을 통해, 컴포넌트 간의 의존성을 최소화하고, 컴포넌트를 개별적으로 배포하고, 교체하거나 업그레이드할 수 있다. 이를 통해, 유지 보수와 업그레이드를 보다 쉽게 처리할 수 있으며, 장애 발생 시 시스템 전체에 영향을 최소화할 수 있다.
```

#### 쿠버네티스의 Metal LB의 역할이 무엇인지?

```
클러스터 내부에서 로드 밸런싱을 할 수 있게 해주는 오픈소스 로드밸런서.

주로 온프레미스 환경에서 사용한다. 일반적으로 CSP를 사용할 때는 CSP 에서 제공하는 로드밸런서 서비스를 사용.
```

#### k8s의 버전 업그레이드 방법은?

```
롤링 업그레이드.

클러스터 노드를 하나씩 중지하고 새로운 버전의 노드로 교체하는 방법이다.
```
#### 쿠버네티스의 Helm 차트에 대해 설명해주세요

```
쿠버네티스를 사용하다 보면 수많은 템플릿을 관리해야 한다. 헬름은 이런 템플릿 파일들의 집합인 차트를 관리하는 쿠버네티스 패키지 매니저 도구이다.

헬름을 이용하면 잘 정리된 차트들로 필요한 애플리케이션들을 빠르게 설치할 수 있다.
헬름 차트는 쿠버네티스 애플리케이션을 설치하는 데 필요한 모든 리소스를 포함한다. 이런 리소스에는 쿠버네티스 매니페스트 파일, 설정 파일, 스크립트 등이 포함 될 수 있다.

헬름의 기본 구성요소는

- 차트: 쿠버네티스에서 실행할 애플리케이션을 만드는 데 필요한 정보 묶음
- 컨피그: 패키지한 차트에 넣어서 배포 가능한 오브젝트를 만들 때 사용할 수 있는 설정
- 릴리즈: 특정 컨피그를 이용해 실행 중인 차트의 인스턴스
```

#### admin.conf 파일 안에 어떤 내용이 들어있는지?

```
쿠버네티스 클러스터 구성파일 중 하나이다. 마스터 노드에 저장되며 kubectl 클라이언트를 설정하는 데 사용된다.

클러스터를 생성할 때 kubeadm init 명령을 실행하면 자동으로 생성. 이 파일을 사용하여 kubectl 클라이언트를 설정하면, kubectl 명령을 사용하여 클러스터에 접근하고, 관리할 수 있다.
```
#### 도커에서 사용한는 오버레이 네트워크에 대해 설명해 보세요.

```
도커에서 오버레이 네트워크(Overlay Network)는 여러 호스트에 분산되어 있는 컨테이너들 간의 통신을 위해 사용되는 가상 네트워크입니다. 오버레이 네트워크는 기존 호스트의 물리적 네트워크 구성과 상관없이 컨테이너 간의 통신을 가능하게 하며, 컨테이너의 IP 주소를 매핑하여 통신합니다.
```
#### 도커 컴포즈가 무엇인지?, 장단점

```
도커 컨테이너 애플리케이션을 정의하고 실행하기 위한 도구. 여러 개의 컨테이너로 이루어진 애플리케이션을 쉽게 관리할 수 있도록 도와주며, YAML 파일 형식으로 애플리케이션의 구성을 정의하고, 하나의 명령으로 애플리케이션을 실행, 중지, 재시작할 수 있다.

장점:
단점: 복잡한 애플리케이션을 다루기에는 한계가 있다. 이를 위해 도커 스웜 등 다른 오케스트레이션 도구를 사용해야 한다.
```

#### 쿠버네티스 클러스터 구성 파일은 무엇이 있는지?

```
대부분 YAML 파일로 정의된다.

API 서버 구성
- API 서버 포트와 IP 주소 설정
- TLS 설정 (인증서 및 키)

etcd 구성
- etcd 서버 포트와 IP 주소 설정
- etcd 클러스터 토폴로지
- TLS 설정 (인증서 및 키)

kubelet 구성
- kubelet의 기본 구성 설정
- TLS 설정 (인증서 및 키)
- kubelet이 사용할 cgroup 드라이버 설정

kube-proxy 구성
- kube-proxy의 기본 구성 설정
- IPVS 설정 (IPVS mode)

쿠버네티스 구성
- 클러스터 네트워크 구성 (CNI 플러그인 설정)
- 쿠버네티스 노드 구성 (kubelet, kube-proxy 설정)
- Pod 네트워크 구성

인증 및 권한 부여
- 사용자 인증 설정 (예: 인증서, 사용자 이름, 암호)
- 롤 기반의 접근 제어 (Role-based Access Control, RBAC) 설정

애드온:
- 쿠버네티스 애드온 (예: DNS, Dashboard, Metrics Server) 구성

스토리지:
- 스토리지 프로바이더 설정
- 스토리지 클래스 및 볼륨 설정

기타:
- 리소스 설정 (예: CPU, 메모리)
- 로깅 및 모니터링 설정
```
#### 도커의 구성요소

```
크게 도커 클라이언트, 도커 데몬, 도커 레지스트리로 구성.

도커 클라이언트: 도커를 사용하기 위한 명령어를 입력하고, 도커 서버와 통신하여 작업 수행

도커 데몬: 도커 클라이언트로부터 받은 명령어를 처리하고, 컨테이너를 생성하고 실행하는 등의 작업 수행. 뒷단에서 백그라운드로 동작하며, 사용자가 직접 접근할 수 없다.

도커 레지스트리: 도커 이미지를 저장하고 관리하는 서버
```

#### 도커 이미지의 레이어 개념에 대해 설명해주세요.

```
도커 이미지는 여러 개의 레이어로 구성되어 있다. 각 레이어는 이전 레이어를 기반으로 생성되며, 변경된 부분만을 포함한다.
이런 개념 덕분에 이미지의 크기를 줄일 수 있다.
```

#### 쿠버네티스 서비스 디스커버리란? 어떻게 동작하는지?

```
클러스터 내부의 서비스들을 찾고, 그 서비스들 간의 통신을 가능하게 하는 기능. 이를 통해 다양한 서비스들이 자동으로 검색되고 서로 통신할 수 있다.

```

#### 쿠버네티스 사용하면서 자주쓴 명령어가 있는지?

```
apply, get, logs, describe 등

```

#### 쿠버네티스에서 어떤 종류의 오브젝트가 있고, 각각 어떤 역할을 하나요?

```
파드, 서비스, 컨피그맵, 디플로이먼트, 데몬셋, 잡, 볼륨 등이 있다.

```

#### 쿠버네티스 파드에 대해

```
가장 작은 배포 단위로 하나 이상의 컨테이너로 구성되어 있다.

파드로 컨테이너 여러 개를 한꺼번에 관리할 때는 컨테이너 마다 역할을 부여할 수 있다.

파드안에 있는 컨테이너들은 IP를 공유한다. 파드 안 컨테이너와 통신할 떄는 컨테이너마다 다르게 설정한 포트를 사용한다.

파드는 다음과 같은 역할을 수행한다.

- 컨테이너 실행: 파드는 하나 이상의 컨테이너를 포함하며, 컨테이너는 같은 파드 내에서 실행됩니다.

- 네트워크: 파드는 동일한 IP 주소와 포트 공간을 공유합니다. 이를 통해 파드 간에 통신할 수 있습니다.

- 스토리지: 파드는 공유 볼륨을 사용하여 데이터를 공유할 수 있습니다.

- 재시작: 파드는 실패하면 자동으로 다시 시작됩니다.

파드는 단일 컨테이너 애플리케이션에서도 사용할 수 있지만, 대부분의 경우 여러 컨테이너를 함께 실행하는 애플리케이션을 배포하기 위해 사용됩니다. 예를 들어, 웹 애플리케이션에서는 웹 서버 컨테이너와 데이터베이스 컨테이너를 같은 파드 내에서 실행할 수 있습니다. 이를 통해 컨테이너 간에 통신이 원활하게 이루어지며, 애플리케이션 전체가 단일 단위로 배포됩니다.
```

#### 파드의 생명주기

```
Pending: 파드를 생성하는 중. 컨테이너 이미지를 다운로드한 후 실행중이므로 시간이 걸린다.
Running: 파드 안 모든 컨테이너가 실행 중인 상태
Succeeded: 파드 안 모든 컨테이너가 정상 실행 종료된 상태로 재시작 되지 않음.
Failed: 파드 안 모든 컨테이너 중 정상적으로 실행 종료되지 않은 컨테이너가 있는 상태
Unknown: 파드의 상태를 확인할 수 없는 상태. 보통 파드가 있는 노드와 통신할 수 없을 때
```

#### 쿠버네티스에서 사용하는 스케줄러는 어떤 종류가 있고, 각각 어떤 역할을 하나요?

```
디폴트 스케줄러: 노드를 선택할 때 노드의 자원 상태와 파드의 요구 사항을 고려

노드 어피니티 스케줄러: Node Label을 사용하여 파드를 실행할 노드를 선택
```

#### 쿠버네티스에서 레플리카셋은 무엇이며, 어떤 역할을 하나요?

```
파드를 관리하는 오브젝트이다. 사용자가 지정한 수만큼 파드를 실행하도록 유지한다.
```

#### 

```
```

#### 

```
```


Reference
- https://kubernetes.io/docs/home/

