#### 마스터 노드 컴포넌트 무엇이 있을까요?

```
Kube-API-Server: 모든 API 호출을 받아들이고 처리하는 컴포넌트. 

etcd: 클러스터의 데이터를 저장하는 key-value 저장소. 쿠버네티스 리소스의 상태 정보, 구성 정보 등을 저장하며, 클러스터의 높은 가용성과 일관성을 보장. 백업 필수.

kube-scheduler: 파드를 노드에 스케줄링. 스케줄링 결정을 위해서 고려되는 요소는 리소스 요구 사항, 하드웨어/소프트웨어/정책적 제약, 어피니티(affinity) 및 안티-어피니티(anti-affinity) 명세, 데이터 지역성, 워크로드-간 간섭, 데드라인을 포함.

kube-controller-manager: API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.

노드 컨트롤러: 노드가 다운되었을 때 통지와 대응에 관한 책임을 가진다.

잡 컨트롤러: 일회성 작업을 나타내는 잡 오브젝트를 감시한 다음, 해당 작업을 완료할 때까지 동작하는 파드를 생성한다.

엔드포인트 컨트롤러: 엔드포인트 오브젝트를 채운다(즉, 서비스와 파드를 연결시킨다.)

서비스 어카운트 & 토큰 컨트롤러: 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성한다.

cloud-controller-manager: 클라우드 컨트롤러 매니저를 통해 클러스터를 클라우드 공급자의 API에 연결하고, 해당 클라우드 플랫폼과 상호 작용하는 컴포넌트와 클러스터와만 상호 작용하는 컴포넌트를 구분할 수 있게 해 준다.
```

#### 쿠버네티스를 왜 써요?

```
컨테이너 오케스트레이션을 위해 필요. 컨테이너 인프라 환경에서 수 많은 컨테이너를 관리하기 위해 필요한 컨테이너 관리 도구중 사실상 표준이다(CNCF 프로젝트). 컨테이너 배포 및 스케줄링, 로드밸런싱 등 오케스트레이션 툴이 없다면 수동으로 제어해야하는 작업들을 자동화 하여 서비스 운영에 도움을 준다.

쿠버네티스를 사용하면 확장성, 가용성, 자동화에 도움이된다.

확장성: 쿠버네티스는 자동으로 노드를 추가하고 컨테이너를 배포하여 처리하여 애플리케이션 부하 증가에도 대처가 쉽다.
가용성: 쿠버네티스는 여러 노드에 컨테이너를 분산시켜 실행하므로, 단일 노드나 컨테이너의 장애가 발생해도 애플리케이션의 가용성을 보장할 수 있다.
자동화: 컨테이너 배포및 스케일링을 자동화하여 운영 자동화에 도움을 준다.
```

#### 쿠버네티스 동작 과정

```
1. 컨테이너 이미지 빌드 및 레지스트리 등록
먼저, 개발자는 애플리케이션을 컨테이너 이미지로 빌드합니다. 이때, Docker와 같은 도구를 사용하여 이미지를 생성하고, 이를 레지스트리에 등록합니다.

2. 쿠버네티스 오브젝트 생성
다음으로, 쿠버네티스 클러스터를 구성하는 노드들에게 컨테이너를 배포하기 위해 쿠버네티스 오브젝트를 생성합니다. 쿠버네티스 오브젝트는 YAML 파일 형태로 정의되며, 파드(Pod), 레플리카셋(ReplicaSet), 디플로이먼트(Deployment) 등이 포함됩니다.

3. 컨트롤러의 동작

마지막으로, 쿠버네티스 컨트롤러들이 생성된 쿠버네티스 오브젝트를 기반으로 노드에 컨테이너를 배포합니다.
노드는 kubelet이라는 에이전트 프로그램을 실행하고 있으며, kubelet은 마스터 노드로부터 할당받은 파드와 컨테이너 정보를 확인하고, 컨테이너를 실행합니다.
이후, 컨트롤러는 레플리카셋의 설정에 따라 파드의 개수를 늘리거나 줄일 수 있으며, 파드의 상태를 주기적으로 확인하고, 장애가 발생한 경우 자동으로 파드를 재시작합니다.
```


#### 쿠버네티스에서 헬스체크를 어떻게 하는지?

```
헬스체크는 쿠버네티스에서 파드를 모니터링하고 상태를 정기적으로 확인하고 대처하는 매커니즘이다.

헬스체크 방법으로는 Liveness Probe, Readiness Probe가 있다.

Liveness Probe: 컨테이너가 정상적으로 실행되는지 확인. 정상 실행 상태가 아니면 kubelet이 컨테이너 실행을 중단시키고 컨테이너의 재시작 정책에 따라 컨테이너를 재시작한다.
Readiness Probe: 실제로 컨테이너가 요청을 처리할 준비가 되어있는지 확인. 일정 시간 내에 응답을 받지 못하면 파드가 서비스 프록시에서 제외된다.
```

#### 쿠버네티스 DNS 시스템이 어떻게 되는지?

```
쿠버네티스 클러스터는 DNS 시스템을 내장하여, 클러스터 내부에서 SD를 제공. 이를 통해, 클러스터 내부의 파드와 서비스를 찾아서 통신할 수 있다.
기본적으로 CoreDNS를 사용한다. 각 서비스마다 자동으로 DNS 이름을 생성한다. 예를 들어, my-service라는 서비스가 default 네임스페이스에 있을 경우, DNS 이름은 my-service.default.svc.cluster.local이 된다.
```

#### 쿠버네티스 클러스터의 고가용성을 위해 무엇을 해야할까?

```
1. 마스터 노드의 HA: 마스터 노드를 여러대로 구성한다. 마스터 노드는 클러스터 상태 정보를 저장하는 DB인 ectd를 사용한다.
etcd 클러스터는 여러 대의 마스터 노드로 구성되며, 각 노드는 etcd 데이터를 복제하여 동기화 한다.
etcd 클러스터의 고가용성을 보장해야한다. 이를 위해 마스터 노드의 쿼럼을 깨지지 않게 해야한다.
쿼럼은 클러스터에서 다수의 노드가 동의하는 것을 나타내는데, 다수의 노드가 공동으로 데이터를 관리하며, 하나의 노드가 고장 나더라도 클러스터 전체가 정상적으로 동작할 수 있다.
quorum = (노드 수 / 2) + 1
2. 노드의 HA: 노드가 다운되었을 때 다른 노드에 파드를 재할당할 수 있어야 합니다. 이를 위해, 레플리카셋(ReplicaSet)을 사용하여 파드를 복제하고, 파드를 다른 노드에 재할당할 수 있도록 합니다.
3. 스토리지의 HA: 스토리지를 여러 노드에 분산하여 저장하고, 복제하여 데이터를 안전하게 보호합니다. 이를 위해, 쿠버네티스에서는 StatefulSet과 같은 오브젝트를 사용하여 스토리지를 관리
4. 네트워크의 HA: 다중 네트워크 인터페이스를 사용하고, 여러 노드에서 동작하는 kube-proxy를 사용하여 로드 밸런싱을 수행합니다.
5. 백업 및 복구 전략: 백업 및 복구 전략을 수립하여 데이터를 안전하게 보호할 수 있도록 합니다.
```

#### 도커 왜 써요?

```
리소스를 격리하기 위해 가상화라는 개념이 등장했다. 가상화는 호스트 OS 위에 여러개의 독립된 게스트 OS를 띄워서 사용한다. 이런 가상화의 문제점은 이미지가 거대해지고(Guest OS에 커널을 포함) 성능 손실이 발생(Host OS를 거쳐야 하기 때문)한다는 것이다. 이 문제를 해결하기 위해 컨테이너가 나왔다. 도커 엔진 위에 컨테이너가 할당된다. 컨테이너는 애플리케이션을 구동하는 데 필요한 라이브러리 및 실행파일만 존재하기 때문에 이미지가 가볍다. 결과적으로, 도커를 사용하면 더 가볍고 빠르게 격리된 환경에서 애플리케이션을 구동할 수 있다.
```

#### 도커 레지스트리란? 어떤 레지스트리 사용했는지?

```
도커 이미지를 저장하고 관리하는 저장소.
도커 허브와 같은 퍼블릭 레지스트리가 있고, 하버나 넥서스 같은 프라이빗 레지스트리가 있다.
```

#### 도커의 동작 방식

```
도커 이미지 생성: 도커는 먼저 이미지를 생성합니다. 이미지는 컨테이너를 실행하는 데 필요한 파일과 설정 등을 포함한 패키지입니다. 도커 이미지는 Dockerfile이라는 특별한 문법을 사용하여 정의됩니다.

도커 이미지 저장: 생성된 이미지는 도커 레지스트리에 저장됩니다. 도커 레지스트리는 이미지를 중앙에서 관리하고, 다른 사용자나 개발자와 공유할 수 있도록 지원하는 서비스입니다.

도커 컨테이너 생성: 저장된 이미지를 바탕으로 도커는 컨테이너를 생성합니다. 컨테이너는 이미지에서 생성된 가상 환경이며, 애플리케이션을 실행하기 위한 필요한 모든 요소를 포함합니다.

컨테이너 실행: 생성된 컨테이너는 도커 엔진에 의해 실행됩니다. 컨테이너는 호스트 운영체제와는 독립적으로 실행되며, 애플리케이션의 실행 및 관리를 위한 필요한 기능을 제공합니다.

컨테이너 간 통신: 컨테이너는 네트워크를 통해 다른 컨테이너나 호스트 시스템과 통신할 수 있습니다. 컨테이너 간 통신을 위해 도커는 가상 네트워크를 제공하며, 컨테이너를 가상 네트워크에 연결하여 통신할 수 있습니다.

컨테이너 관리: 도커는 컨테이너를 관리하는 다양한 도구를 제공합니다. 이를 통해, 컨테이너의 상태 모니터링, 로깅, 설정 관리 등을 쉽게 수행할 수 있습니다.

컨테이너 삭제: 컨테이너를 더 이상 사용하지 않을 때, 도커는 해당 컨테이너를 삭제할 수 있습니다. 컨테이너를 삭제하면, 해당 컨테이너에서 실행 중인 애플리케이션과 관련된 데이터도 함께 삭제됩니다.
```

#### 도커 이미지란?

```
도커 이미지는 컨테이너를 생성하기 위한 실행 파일과 런타임 환경 등의 정보를 담고 있으
```

#### 컨테이너의 생명주기

```

이미지 생성: 먼저, Dockerfile 등의 설정을 통해 Docker 이미지를 생성합니다.

컨테이너 생성: 생성된 Docker 이미지를 바탕으로 컨테이너를 생성합니다.

컨테이너 시작: 생성된 컨테이너를 시작합니다.

컨테이너 실행: 컨테이너는 실행 중인 상태로 애플리케이션을 수행합니다.

컨테이너 일시 중지: 컨테이너를 일시 중지할 수 있습니다. 이때 컨테이너는 아직 메모리에 상주하며, 다시 시작할 수 있습니다.

컨테이너 종료: 컨테이너가 종료됩니다. 이때 컨테이너가 사용하던 자원은 반납됩니다.

컨테이너 삭제: 더 이상 필요하지 않은 컨테이너는 삭제됩니다. 이때 컨테이너 이미지는 유지됩니다.
```

#### 쿠버네티스 서비스 종류와 쓰임

```
쿠버네티스 파드는 컨트롤러가 관리하고, 한 군데에 고정되어있는 것이 아니라 클러스터 안을 옮겨 다닌다.
그렇기에 파드에 접근하는 방식이 필요하고 이를 서비스라고 한다.
서비스를 사용하면 고정 주소를 이용해 접근할 수 있다.

서비스 타입에는 크게 네 가지가 있다.

ClusterIP: 쿠버네티스 클러스터 내부에서만 접근 가능한 IP를 할당하는 서비스입니다. 여러 개의 포드를 하나의 IP로 묶어서 관리하며, 쿠버네티스의 내부 네트워크를 통해 접근할 수 있습니다.

NodePort: 쿠버네티스 클러스터 외부에서도 접근 가능한 포트를 열어주는 서비스입니다. 클러스터 내부에서의 ClusterIP 서비스와 함께 사용하여, 외부에서도 쿠버네티스 애플리케이션에 접근할 수 있도록 지원합니다. 
서비스 하나에 모든 노드의 지정된 포트를 할당한다. 
예) node1:8080 node2:8080

LoadBalancer: 클라우드 서비스가 제공하는 로드 밸런서와 파드를 연결하는 서비스입니다. 
해당 로드 밸런서의 IP를 이용해 클러스터 외부에서의 애플리케이션 접근을 지원하며 부하분산이 가능하다.

ExternalName: 외부 DNS 이름을 내부 클러스터에서 사용할 수 있도록 지원하는 서비스입니다. 즉, 서비스의 이름을 DNS 이름으로 지정하여, 클러스터 내부에서 외부 리소스에 접근할 수 있도록 합니다.

```

#### 도커 이미지란?

```
도커 이미지는 도커 컨테이너를 실행하기 위한 파일들의 묶음이다.

이미지는 레이어라는 개념을 사용하여 구성된다. 각 레이어는 이전 레이어를 기반으로 만들어진다. 변경사항이 있는 경우 전체 이미지를 다시 빌드하지 않고 변경된 레이어만 다시 빌드할 수 있도록 한다.
```

#### 쿠버네티스 인그레스와 서비스의 차이점
```
인그레스와 서비스는 모두 쿠버네티스 네트워크 개념이다.

인그레스는 클러스터 외부에서 내부로의 액세스를 제공하기 위한 기능이다. 일반적으로 HTTP 프로토콜을 사용하며, 로드 밸런싱과 SSL 종료 등의 기능을 제공.
인그레스를 사용하려면 인그레스 컨트롤러를 설치해야 한다. 인그레스 컨트롤러는 인그레스 규칙을 처리하고 요청을 적절한 서비스로 라우팅한다. 일반적으로 인그레스 컨트롤러는 Nginx, HAProxy와 같은 리버스 프록시를 사용한다.

서비스는 클러스터 내부에서 파드와 같은 워크로드에 대한 네트워크 엔드포인트를 노출하는 리소스. 서비스는 동일한 라벨 셀렉터를 사용하여 파드를 그룹화하고, 그룹 내의 파드에 대한 로드 밸런싱을 수행하며, 그룹 내 파드가 죽거나 생성될 때 업데이트를 자동으로 수행한다. 서비스는 일반적으로 TCP/UDP 프로토콜을 사용.

```
#### 쿠버네티스에서 셀프힐링하는 방법

```
1. 리드니스 프로브, 라이브니스 프로브
2. 노드 자동 복구: 노드에 장애가 발생하면 해당 노드의 파드를 다른 노드로 마이그레이션
```

#### 쿠버네티스 컨셉

```
느슨한 결합(Loose Coupling): 쿠버네티스는 애플리케이션의 컴포넌트를 느슨하게 결합하도록 설계되었다. 이를 통해, 컴포넌트를 개별적으로 배포하고, 교체하거나 업그레이드할 수 있다.

선언적(Declarative): 쿠버네티스는 선언적 API이다. 원하는 상태를 선언하면 쿠버네티스가 이를 달성하기 위해 자동으로 상태를 감시하고 변경한다.

자기 치유(Self-Healing): 쿠버네티스는 시스템의 가용성을 유지하기 위해 자동으로 문제를 해결하거나, 복구하는 기능을 제공.

자동화(Automated): 쿠버네티스는 시스템의 자동화를 지향. 따라서, 애플리케이션의 배포, 확장, 복구, 롤백 등의 작업을 자동으로 처리할 수 있다.

확장 가능(Scalable): 쿠버네티스는 수천 개의 노드(Node)를 지원하며, 클러스터의 크기를 쉽게 확장할 수 있다.

포터블(Portable): 쿠버네티스는 여러 환경에서 동일한 방식으로 실행할 수 있도록 설계되었다.
```

#### 느슨한 결합이란?

```
애플리케이션을 구성하는 컴포넌트들은 보통 서로 밀접하게 연결되어있다. 예를들어 웹 애플리케이션은 프론트엔드, 백엔드, DB 등의 컴포넌트가 서로 밀접하게 연결되어있다. 이런 구성에서는 하나의 컴포넌트를 변경하면 다른 컴포넌트도 함께 변경되야 하므로 유지 보수가 어렵고 장애 발생 시 시스템 전체에 영향을 미칠 수 있다.

쿠버네티스에서는 이러한 문제를 해결하기 위해 컴포넌트 간의 결합도를 낮추는 설계 철학을 따른다. 각 컴포넌트는 독립적인 프로세스로 실행되며, 서로 다른 노드에 배포될 수 있다.

쿠버네티스에서는 이러한 느슨한 결합을 구현하기 위해 다양한 기능을 제공한다. 예를 들어 각 파드는 독립적인 IP 주소를 가지며, 다른 파드와 통신할 때는 서비스를 사용한다. 서비스는 파드를 논리적으로 그룹화하여, 외부에서 파드에 접근할 때 로드 밸런싱과 같은 기능을 제공한다.

또한, 쿠버네티스에서는 컨트롤러를 사용하여 각 컴포넌트의 상태를 감시하고, 필요한 경우 컴포넌트의 수를 늘리거나 줄인다. 이를 통해, 컴포넌트의 수를 동적으로 조절하여 리소스를 효율적으로 활용할 수 있다.

또한, 쿠버네티스에서는 컨테이너 이미지를 사용하여 애플리케이션을 배포한다. 컨테이너 이미지는 독립적으로 실행될 수 있는 패키지로, 각 컴포넌트를 컨테이너 이미지로 패키징하여 배포한다. 이를 통해, 컴포넌트 간의 의존성을 낮추고, 배포 및 업그레이드를 보다 쉽게 처리할 수 있습니다.

또한, 쿠버네티스에서는 롤링 업데이트 기능을 제공합니다. 롤링 업데이트는 애플리케이션의 업그레이드를 점진적으로 처리하여, 장애 발생 시 시스템 전체에 영향을 최소화한다. 이를 통해, 애플리케이션의 가용성을 높일 수 있습니다.

쿠버네티스에서는 이러한 느슨한 결합을 통해, 컴포넌트 간의 의존성을 최소화하고, 컴포넌트를 개별적으로 배포하고, 교체하거나 업그레이드할 수 있다. 이를 통해, 유지 보수와 업그레이드를 보다 쉽게 처리할 수 있으며, 장애 발생 시 시스템 전체에 영향을 최소화할 수 있다.
```

#### 

```
```


Reference
- https://kubernetes.io/docs/home/

