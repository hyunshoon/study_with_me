#### 마스터 노드 컴포넌트 무엇이 있을까요?

```
Kube-API-Server: 모든 API 호출을 받아들이고 처리하는 컴포넌트. 

etcd: 클러스터의 데이터를 저장하는 key-value 저장소. 쿠버네티스 리소스의 상태 정보, 구성 정보 등을 저장하며, 클러스터의 높은 가용성과 일관성을 보장. 백업 필수.

kube-scheduler: 파드를 노드에 스케줄링. 스케줄링 결정을 위해서 고려되는 요소는 리소스 요구 사항, 하드웨어/소프트웨어/정책적 제약, 어피니티(affinity) 및 안티-어피니티(anti-affinity) 명세, 데이터 지역성, 워크로드-간 간섭, 데드라인을 포함.

kube-controller-manager: API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.

노드 컨트롤러: 노드가 다운되었을 때 통지와 대응에 관한 책임을 가진다.

잡 컨트롤러: 일회성 작업을 나타내는 잡 오브젝트를 감시한 다음, 해당 작업을 완료할 때까지 동작하는 파드를 생성한다.

엔드포인트 컨트롤러: 엔드포인트 오브젝트를 채운다(즉, 서비스와 파드를 연결시킨다.)

서비스 어카운트 & 토큰 컨트롤러: 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성한다.

cloud-controller-manager: 클라우드 컨트롤러 매니저를 통해 클러스터를 클라우드 공급자의 API에 연결하고, 해당 클라우드 플랫폼과 상호 작용하는 컴포넌트와 클러스터와만 상호 작용하는 컴포넌트를 구분할 수 있게 해 준다.
```

#### 쿠버네티스를 왜 써요?

```
컨테이너 오케스트레이션을 위해 필요. 컨테이너 인프라 환경에서 수 많은 컨테이너를 관리하기 위해 필요한 컨테이너 관리 도구중 사실상 표준이다(CNCF 프로젝트). 컨테이너 배포 및 스케줄링, 로드밸런싱 등 오케스트레이션 툴이 없다면 수동으로 제어해야하는 작업들을 자동화 하여 서비스 운영에 도움을 준다.

쿠버네티스를 사용하면 확장성, 가용성, 자동화에 도움이된다.

확장성: 쿠버네티스는 자동으로 노드를 추가하고 컨테이너를 배포하여 처리하여 애플리케이션 부하 증가에도 대처가 쉽다.
가용성: 쿠버네티스는 여러 노드에 컨테이너를 분산시켜 실행하므로, 단일 노드나 컨테이너의 장애가 발생해도 애플리케이션의 가용성을 보장할 수 있다.
자동화: 컨테이너 배포및 스케일링을 자동화하여 운영 자동화에 도움을 준다.
```

#### 쿠버네티스 동작 과정

```
1. 컨테이너 이미지 빌드 및 레지스트리 등록
먼저, 개발자는 애플리케이션을 컨테이너 이미지로 빌드합니다. 이때, Docker와 같은 도구를 사용하여 이미지를 생성하고, 이를 레지스트리에 등록합니다.

2. 쿠버네티스 오브젝트 생성
다음으로, 쿠버네티스 클러스터를 구성하는 노드들에게 컨테이너를 배포하기 위해 쿠버네티스 오브젝트를 생성합니다. 쿠버네티스 오브젝트는 YAML 파일 형태로 정의되며, 파드(Pod), 레플리카셋(ReplicaSet), 디플로이먼트(Deployment) 등이 포함됩니다.

3. 컨트롤러의 동작

마지막으로, 쿠버네티스 컨트롤러들이 생성된 쿠버네티스 오브젝트를 기반으로 노드에 컨테이너를 배포합니다.
노드는 kubelet이라는 에이전트 프로그램을 실행하고 있으며, kubelet은 마스터 노드로부터 할당받은 파드와 컨테이너 정보를 확인하고, 컨테이너를 실행합니다.
이후, 컨트롤러는 레플리카셋의 설정에 따라 파드의 개수를 늘리거나 줄일 수 있으며, 파드의 상태를 주기적으로 확인하고, 장애가 발생한 경우 자동으로 파드를 재시작합니다.
```


#### 쿠버네티스에서 헬스체크를 어떻게 하는지?

```
헬스체크는 쿠버네티스에서 파드를 모니터링하고 상태를 정기적으로 확인하고 대처하는 매커니즘이다.

헬스체크 방법으로는 Liveness Probe, Readiness Probe가 있다.

Liveness Probe: 컨테이너가 정상적으로 실행되는지 확인. 정상 실행 상태가 아니면 kubelet이 컨테이너 실행을 중단시키고 컨테이너의 재시작 정책에 따라 컨테이너를 재시작한다.
Readiness Probe: 실제로 컨테이너가 요청을 처리할 준비가 되어있는지 확인. 일정 시간 내에 응답을 받지 못하면 파드가 서비스 프록시에서 제외된다.
```

#### 쿠버네티스 DNS 시스템이 어떻게 되는지?

```
쿠버네티스 클러스터는 DNS 시스템을 내장하여, 클러스터 내부에서 SD를 제공. 이를 통해, 클러스터 내부의 파드와 서비스를 찾아서 통신할 수 있다.
기본적으로 CoreDNS를 사용한다. 각 서비스마다 자동으로 DNS 이름을 생성한다. 예를 들어, my-service라는 서비스가 default 네임스페이스에 있을 경우, DNS 이름은 my-service.default.svc.cluster.local이 된다.
```

#### 쿠버네티스 클러스터의 고가용성을 위해 무엇을 해야할까?

```
1. 마스터 노드의 HA: 마스터 노드를 여러대로 구성한다. 마스터 노드는 클러스터 상태 정보를 저장하는 DB인 ectd를 사용한다.
etcd 클러스터는 여러 대의 마스터 노드로 구성되며, 각 노드는 etcd 데이터를 복제하여 동기화 한다.
etcd 클러스터의 고가용성을 보장해야한다. 이를 위해 마스터 노드의 쿼럼을 깨지지 않게 해야한다.
쿼럼은 클러스터에서 다수의 노드가 동의하는 것을 나타내는데, 다수의 노드가 공동으로 데이터를 관리하며, 하나의 노드가 고장 나더라도 클러스터 전체가 정상적으로 동작할 수 있다.
quorum = (노드 수 / 2) + 1
2. 노드의 HA: 노드가 다운되었을 때 다른 노드에 파드를 재할당할 수 있어야 합니다. 이를 위해, 레플리카셋(ReplicaSet)을 사용하여 파드를 복제하고, 파드를 다른 노드에 재할당할 수 있도록 합니다.
3. 스토리지의 HA: 스토리지를 여러 노드에 분산하여 저장하고, 복제하여 데이터를 안전하게 보호합니다. 이를 위해, 쿠버네티스에서는 StatefulSet과 같은 오브젝트를 사용하여 스토리지를 관리
4. 네트워크의 HA: 다중 네트워크 인터페이스를 사용하고, 여러 노드에서 동작하는 kube-proxy를 사용하여 로드 밸런싱을 수행합니다.
5. 백업 및 복구 전략: 백업 및 복구 전략을 수립하여 데이터를 안전하게 보호할 수 있도록 합니다.
```

#### 도커 왜 써요?

```
리소스를 격리하기 위해 가상화라는 개념이 등장했다. 가상화는 호스트 OS 위에 여러개의 독립된 게스트 OS를 띄워서 사용한다. 이런 가상화의 문제점은 이미지가 거대해지고(Guest OS에 커널을 포함) 성능 손실이 발생(Host OS를 거쳐야 하기 때문)한다는 것이다. 이 문제를 해결하기 위해 컨테이너가 나왔다. 도커 엔진 위에 컨테이너가 할당된다. 컨테이너는 애플리케이션을 구동하는 데 필요한 라이브러리 및 실행파일만 존재하기 때문에 이미지가 가볍다. 결과적으로, 도커를 사용하면 더 가볍고 빠르게 격리된 환경에서 애플리케이션을 구동할 수 있다.
```

#### 도커 레지스트리란? 어떤 레지스트리 사용했는지?

```
도커 이미지를 저장하고 관리하는 저장소.
도커 허브와 같은 퍼블릭 레지스트리가 있고, 하버나 넥서스 같은 프라이빗 레지스트리가 있다.
```

#### 도커의 동작 방식

```
도커 이미지 생성: 도커는 먼저 이미지를 생성합니다. 이미지는 컨테이너를 실행하는 데 필요한 파일과 설정 등을 포함한 패키지입니다. 도커 이미지는 Dockerfile이라는 특별한 문법을 사용하여 정의됩니다.

도커 이미지 저장: 생성된 이미지는 도커 레지스트리에 저장됩니다. 도커 레지스트리는 이미지를 중앙에서 관리하고, 다른 사용자나 개발자와 공유할 수 있도록 지원하는 서비스입니다.

도커 컨테이너 생성: 저장된 이미지를 바탕으로 도커는 컨테이너를 생성합니다. 컨테이너는 이미지에서 생성된 가상 환경이며, 애플리케이션을 실행하기 위한 필요한 모든 요소를 포함합니다.

컨테이너 실행: 생성된 컨테이너는 도커 엔진에 의해 실행됩니다. 컨테이너는 호스트 운영체제와는 독립적으로 실행되며, 애플리케이션의 실행 및 관리를 위한 필요한 기능을 제공합니다.

컨테이너 간 통신: 컨테이너는 네트워크를 통해 다른 컨테이너나 호스트 시스템과 통신할 수 있습니다. 컨테이너 간 통신을 위해 도커는 가상 네트워크를 제공하며, 컨테이너를 가상 네트워크에 연결하여 통신할 수 있습니다.

컨테이너 관리: 도커는 컨테이너를 관리하는 다양한 도구를 제공합니다. 이를 통해, 컨테이너의 상태 모니터링, 로깅, 설정 관리 등을 쉽게 수행할 수 있습니다.

컨테이너 삭제: 컨테이너를 더 이상 사용하지 않을 때, 도커는 해당 컨테이너를 삭제할 수 있습니다. 컨테이너를 삭제하면, 해당 컨테이너에서 실행 중인 애플리케이션과 관련된 데이터도 함께 삭제됩니다.
```

#### 도커 이미지란?

```
도커 이미지는 컨테이너를 생성하기 위한 실행 파일과 런타임 환경 등의 정보를 담고 있으
```

#### 컨테이너의 생명주기

```

이미지 생성: 먼저, Dockerfile 등의 설정을 통해 Docker 이미지를 생성합니다.

컨테이너 생성: 생성된 Docker 이미지를 바탕으로 컨테이너를 생성합니다.

컨테이너 시작: 생성된 컨테이너를 시작합니다.

컨테이너 실행: 컨테이너는 실행 중인 상태로 애플리케이션을 수행합니다.

컨테이너 일시 중지: 컨테이너를 일시 중지할 수 있습니다. 이때 컨테이너는 아직 메모리에 상주하며, 다시 시작할 수 있습니다.

컨테이너 종료: 컨테이너가 종료됩니다. 이때 컨테이너가 사용하던 자원은 반납됩니다.

컨테이너 삭제: 더 이상 필요하지 않은 컨테이너는 삭제됩니다. 이때 컨테이너 이미지는 유지됩니다.
```

#### 쿠버네티스 서비스 종류와 쓰임

```
쿠버네티스 파드는 컨트롤러가 관리하고, 한 군데에 고정되어있는 것이 아니라 클러스터 안을 옮겨 다닌다.
그렇기에 파드에 접근하는 방식이 필요하고 이를 서비스라고 한다.
서비스를 사용하면 고정 주소를 이용해 접근할 수 있다.

서비스 타입에는 크게 네 가지가 있다.

ClusterIP: 쿠버네티스 클러스터 내부에서만 접근 가능한 IP를 할당하는 서비스입니다. 여러 개의 포드를 하나의 IP로 묶어서 관리하며, 쿠버네티스의 내부 네트워크를 통해 접근할 수 있습니다.

NodePort: 쿠버네티스 클러스터 외부에서도 접근 가능한 포트를 열어주는 서비스입니다. 클러스터 내부에서의 ClusterIP 서비스와 함께 사용하여, 외부에서도 쿠버네티스 애플리케이션에 접근할 수 있도록 지원합니다. 
서비스 하나에 모든 노드의 지정된 포트를 할당한다. 
예) node1:8080 node2:8080

LoadBalancer: 클라우드 서비스가 제공하는 로드 밸런서와 파드를 연결하는 서비스입니다. 
해당 로드 밸런서의 IP를 이용해 클러스터 외부에서의 애플리케이션 접근을 지원하며 부하분산이 가능하다.

ExternalName: 외부 DNS 이름을 내부 클러스터에서 사용할 수 있도록 지원하는 서비스입니다. 즉, 서비스의 이름을 DNS 이름으로 지정하여, 클러스터 내부에서 외부 리소스에 접근할 수 있도록 합니다.

```

#### 

```

```

#### 

```

```

#### 

```

```

#### 

```

```

#### 

```

```

#### 

```

```



